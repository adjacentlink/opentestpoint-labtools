#
# Copyright (c) 2019 - Adjacent Link LLC, Bridgewater, New Jersey
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of Adjacent Link LLC nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

"""Produce window average from long running average labtools variable
instance.

A WindowAverage observer produces a windowed average from a long
running average subject data.

"""

from .subject import Subject
from .observer import Observer
import pandas as pd
import numpy as np
from collections import defaultdict

class WindowAverage(Subject,Observer):
    """Produce window average value from a long running average and sample
    size data.

    WindowAverage modifiers work on subjects with single value state
    by tag.

      * val

    """
    def __init__(self,avg_variable,count_variables,**kwargs):
        """Creates a WindowAverage modifier instance.

        Args:
            avg_variable (Subject): Long running average variable to window.

            count_variables ([Subject]): List or tuple of variables to
                                         sum to represent the running
                                         average sample size.

        Keyword Args:
            name (str): Modified variable name. Default: WindowAverage(variable).

        Example::

            stream.model(WindowAverage(varAvgTimedEventLatency,(varProcessedTimedEvents,)),
                         WindowAverage(varAvgProcessAPIQueueWait,(varProcessedConfiguration,
                                                                 varProcessedDownstreamControl,
                                                                 varProcessedDownstreamPackets,
                                                                 varProcessedEvents,
                                                                 varProcessedTimedEvents,
                                                                 varProcessedUpstreamControl,
                                                                 varProcessedUpstreamPackets)),
                         ...)

        """
        Subject.__init__(self,avg_variable.stream())
        Observer.__init__(self)
        self._window_avgs = defaultdict(lambda : defaultdict(lambda:np.nan))
        self._updated = set()
        self._name = kwargs.pop('name',None)

        if self._name == None:
            self._name = "WindowAverage(%s)" % avg_variable.name()

        if kwargs:
            raise KeyError("Unknown key(s): %s" % ", ".join(list(kwargs.keys())))

        self._vars = []
        self._vars.append(avg_variable)
        self._vars.extend(list(count_variables))

        stream = self._vars[0].stream()

        for var in self._vars:
            if stream != var.stream():
                raise ValueError('variable subjects must be from the same stream')

            var.attach(self)

        self._window_avgs = defaultdict(lambda : defaultdict(lambda : np.nan))
        self._data = defaultdict(lambda : defaultdict(lambda : [np.nan] * len(self._vars)))
        self._var_index_map = {y:x for x,y in enumerate(self._vars)}

    def name(self):
        """Gets the name of this observer.

        Returns:
            str: Modified variable name.
        """
        return self._name

    def notify(self,subject):
        """
        Processes subject update to produce new state.
        """
        data,updated = subject.state()
        if not data and not updated:
            self._data.clear()
            self._window_avgs.clear()
            self._updated.clear()
            self.notify_observers()
            return

        for timestamp in updated:
            for tag in data[timestamp]:
                self._data[timestamp][tag][self._var_index_map[subject]] = data[timestamp][tag]

        sorted_timestamps = sorted(self._data.keys())

        for timestamp in updated:
            for tag in data[timestamp]:
                previous_timestamp_index = sorted_timestamps.index(timestamp) - 1

                if previous_timestamp_index >= 0:
                    previous_timestamp =  sorted_timestamps[previous_timestamp_index]
                    current_count = sum(self._data[timestamp][tag][1:])
                    previous_count = sum(self._data[previous_timestamp][tag][1:])

                    if current_count >= previous_count:
                        self._window_avgs[timestamp][tag] = (current_count * self._data[timestamp][tag][0] - previous_count * self._data[previous_timestamp][tag][0]) / (current_count - previous_count)
                    else:
                        self._window_avgs[timestamp][tag] = np.nan

        # remove values in data cache and previous data no longer
        # available in subject - do after loading new data otherwise
        # you will drop previous value outside the subject cache that
        # may be required to calculate all average windows in the
        # current data set
        for purge in set(self._data.keys()).difference(list(data.keys())):
            del self._data[purge]
            del self._window_avgs[purge]

        self._updated = updated
        self.notify_observers()
        self._updated = set()

    def state(self):
        """Gets the state.

        Returns:
            dict: A dict of with timestamp (int) keys and dict
            values. Where each dict value has tag name (str) keys and
            the window average single value.

        """
        return self._window_avgs,self._updated
